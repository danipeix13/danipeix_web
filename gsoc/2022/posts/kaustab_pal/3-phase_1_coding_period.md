# GSoC'22 RoboComp project: Model Predictive Control for obstacle avoidance 

22nd June 2022

## Phase 1 

Phase 1 started from June 13th. The plan for the phase 1 is to review, correct
and test the existing MPC algorithm.

I started with the **comp-casadi-cpp** component. It had the free-ball
implementation of MPC. 

I tested the algorithm in three different environments: 1. run_beta_bill, 2.
run_beta_bill_walking and 3. run_beta_infirmary. In all of these environments
the trajectory is failing to avoid collisions and is passing right through the
obstacles.

## Result of free-balls trajectory passing through the walls
![](assets/run_beta_infirmary.jpg)

After fiddling with the weights of the cost function and making sure all the
constraints were implemented properly, we concluded that we need specific points
that we can consider in the occupied set to make the freeballs algorithm work. 

Then I moved on to analyzing the **local_grid** component. Here after setting a
target, a path is calculated using the A\* algorithm. After that we follow the
path using either the carrot algorithm or the MPC. 

## Testing the MPC algorithm with static obstacles

1. One of the problem with the MPC was it didn't have any acceleration
   constraints. As a result the velocities would jump arbitrarily and was
   leading to erratic behaviors like suddenly moving very very slowly when it is
   near the obstacles. I fixed this by adding the acceleration constraints to
   the MPC so that there is a smooth change in the velocity of the MPC. [Pull
   request \#3](https://github.com/robocomp/optimizer/pull/3)

2. The path generated by the A\* algorithm is avoiding obstacles and since the
   MPC is simply following that path, it is able to avoid all the static
   obstacles. However the point of failure for the MPC algorithm is if the
   target is given inside an obstacle, the A\* path planner generates a path
   that leads inside the obstacle and since the MPC is following that path, it
   eventually goes and crashes with that obstacle. To solve this issue I made
   use of the local grid. I know which of the grid cells is occupied and which
   of them are free. Using this information I formulated the obstacle avoidance
   constraints considering each occupied cell as an obstacle. However if I take
   all the cells into consideration the number of constraints will be large in
   number and the optimization process will be slower. To avoid that I only
   considered the obstacles which are within a distance of 5m to the robot. I
   also set the minimum velocity as -0.2 m/sec so that the robot can move in the
   reverse direction is necessary. A slight modification to the cost function
   was also made. Initially we were minimizing the distance of the MPC generated
   trajectory to the reference trajectory. However this would force the MPC
   trajectory to overlap with the reference trajectory even if it is in the
   obstacle. To solve that, in the current cost function I am simply minimizing
   the first 6 positions of the MPC trajectory to the reference trajectory.
   After making these changes now the agent is working properly in environments
   with static obstacles. If the target is given within an obstacle then the MPC
   simply keeps moving around the obstacle instead of crashing into it. [Pull
   request \#4](https://github.com/robocomp/optimizer/pull/4)

### Video of the corrected MPC in the environment run_beta_bill

https://youtu.be/AZC3tzMGH5o

## Testing the MPC algorithm with dynamic obstacles

The problem with having negative velocity is that it will make the robot move in the reverse direction and when moving in the reverse direction, it won't be able to percieve the environment and end up colliding with the dynamic obstacles. So to address this issue I kept the minimum velocity as 0 but now enabled the robot to rotate on spot. That way if the target location is behind the robot, the robot will keep rotating without advancing forward untill the target is right in front of it and then use the MPC algorithm to calculate the trajectory to the target. This feature also enables the robot to get unstuck when it collides with a static obstacle. [Pull
   request \#5](https://github.com/robocomp/optimizer/pull/5)

### Video of the MPC in the environment run_beta_bill_walking

https://youtu.be/OsrGKSJUsoo

### Video of the MPC in the environment run_beta

The following video shows how the MPC changes it's trajectory when an obstacle is moved towards it. It also shows that the robot doesn't crash into the obstacle but maintains a safe distance when the target is inside the obstacle. [Pull
   request \#6](https://github.com/robocomp/optimizer/pull/6)

https://youtu.be/U4RgTK7FKog


## Next steps

The current implementation only works for both static and dynamic obstacles. But if the target is placed inside an occupied cell the MPC will go and crash to the target. While it can still recover from that position but it is not an acceptable behavior. So the next step is to make sure the target is in an unoccupied cell even though the user gives it in an occupied cell.
